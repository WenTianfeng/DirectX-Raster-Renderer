#include "Material.h"

Material::Material(ID3D11Device* device, std::wstring vertexShaderFilePath, std::wstring pixelShaderFilePath)
{

	HRESULT hr;

//=========================创建顶点着色器==========================
	this->m_vertexShader.Instantiate(device, Shader::ShaderType::VertexShader,vertexShaderFilePath,"VS_Main","vs_5_0");

//==========================创建输入布局===========================
#pragma region 创建输入布局
	//获取shader反射对象
	Microsoft::WRL::ComPtr<ID3D11ShaderReflection> shaderReflection;
	hr = D3DReflect(m_vertexShader.GetBlob()->GetBufferPointer(), m_vertexShader.GetBlob()->GetBufferSize(), __uuidof(ID3D11ShaderReflection), reinterpret_cast<void**>(shaderReflection.GetAddressOf()));
	COM_ERROR_IF_FAILED(hr, "Failed to reflect vertex shader.");

	//获取着色器描述信息
	D3D11_SHADER_DESC shaderDescription;
	hr = shaderReflection->GetDesc(&shaderDescription);
	COM_ERROR_IF_FAILED(hr, "Failed to get description of vertex shader.");

	//顶点输入结构变量数量
	UINT numInputParameters = shaderDescription.InputParameters;

	//输入布局列表
	std::vector<D3D11_INPUT_ELEMENT_DESC> inputElements;

	//根据着色器定义的顶点输入结构创建输入布局
	for (UINT i = 0; i < numInputParameters; ++i)
	{
		D3D11_INPUT_ELEMENT_DESC inputElement = {};//输入布局列表元素
		D3D11_SIGNATURE_PARAMETER_DESC parameterSignature;//顶点输入结构每个元素的签名

		shaderReflection->GetInputParameterDesc(i, &parameterSignature);

		inputElement.SemanticName = parameterSignature.SemanticName;
		inputElement.SemanticIndex = parameterSignature.SemanticIndex;
		inputElement.InputSlot = 0;
		inputElement.AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		inputElement.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; 
		inputElement.InstanceDataStepRate = 0;
		inputElement.Format = ShaderProcessor::GetDXGIFormat(parameterSignature);

		//如果格式无效，则停止运行
		assert(inputElement.Format != DXGI_FORMAT_UNKNOWN);

		//将输入布局元素加入列表
		inputElements.push_back(inputElement);
	}

	if (inputElements.size() > 0)
	{
		//使用输入布局列表创建输入布局
		hr = device->CreateInputLayout(inputElements.data(), (UINT)inputElements.size(), m_vertexShader.GetBlob()->GetBufferPointer(), m_vertexShader.GetBlob()->GetBufferSize(), this->m_dxInputLayout.GetAddressOf());
		COM_ERROR_IF_FAILED(hr, L"Failed to create DirectX Input Layout.");
	}
#pragma endregion

//==========================创建像素着色器==========================

	this->m_pixelShader.Instantiate(device, Shader::ShaderType::PixelShader, pixelShaderFilePath, "PS_Main", "ps_5_0");

//========================创建深度-模板缓冲状态=======================

	//深度模板测试状态描述
	D3D11_DEPTH_STENCIL_DESC dsc;
	ZeroMemory(&dsc, sizeof(dsc));
	dsc.DepthEnable = true;
	dsc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	dsc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;
	dsc.StencilEnable = false;
	//……………………其余模板缓冲描述待填写……………………

	hr = device->CreateDepthStencilState(&dsc, m_dxDepthStencilState.GetAddressOf());
	//错误检查
	COM_ERROR_IF_FAILED(hr, L"Failed to create DirectX DepthStencil State.");


//==========================创建混合状态===========================
#pragma region 创建混合状态
	D3D11_BLEND_DESC bd;
	ZeroMemory(&bd, sizeof(bd));

	D3D11_RENDER_TARGET_BLEND_DESC rtbd;
	ZeroMemory(&rtbd, sizeof(rtbd));

	rtbd.BlendEnable = false;
	rtbd.BlendOp = D3D11_BLEND_OP_ADD; //颜色混合运算方法
	rtbd.SrcBlend = D3D11_BLEND_SRC_ALPHA; //源颜色因子
	rtbd.DestBlend = D3D11_BLEND_INV_SRC_ALPHA; //缓冲区颜色因子
	rtbd.SrcBlendAlpha = D3D11_BLEND_ONE; //源透明度因子
	rtbd.DestBlendAlpha = D3D11_BLEND_ZERO; //缓冲区透明度因子
	rtbd.BlendOpAlpha = D3D11_BLEND_OP_ADD; //透明度混合运算方法
	rtbd.RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL; //颜色遮罩

	bd.RenderTarget[0] = rtbd;

	hr = device->CreateBlendState(&bd, this->m_dxBlendState.GetAddressOf());
	//错误检查
	COM_ERROR_IF_FAILED(hr, L"Failed to create DirectX Blend State.");

#pragma endregion 

//==========================创建常量缓冲===========================

	this->m_transformMatrixCB.Instantiate(device);

}

Shader Material::GetVertexShader()
{
	return this->m_vertexShader;
}

Shader Material::GetPixelShader()
{
	return this->m_pixelShader;
}

ID3D11InputLayout* Material::GetInputLayout()
{
	return this->m_dxInputLayout.Get();
}

ID3D11DepthStencilState* Material::GetDepthStencilState()
{
	return this->m_dxDepthStencilState.Get();
}

ID3D11BlendState* Material::GetBlendState()
{
	return this->m_dxBlendState.Get();
}

ConstantBuffer<CB_VS_TransformMatrix>& Material::GetConstantBuffer_TransformMatrix()
{
	return this->m_transformMatrixCB;
}



